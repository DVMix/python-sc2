from .ids.id_version import ID_VERSION_STRING

from .game_data import AbilityData, UnitTypeData, UpgradeData, GameData

from pathlib import Path
import importlib
import sys

from typing import List, Tuple, Dict

from loguru import logger


class IdUpdater:
    def __init__(self, game_data: GameData = None, game_version: str = "", verbose=False):
        self.game_data = game_data
        self.game_version = game_version
        self.verbose = verbose

        self.sc2_folder_path = Path(__file__).parent

        self.file_header = """# DO NOT EDIT!
# This file was automatically generated by "generate_id_constants_from_stableid.py"

import enum

"""
        self.class_header = "class {}(enum.Enum):\n"  # string.format("AbilityId")

        self.file_footer = """
    def __repr__(self):
        return "{}." + self.name


for item in {}:
    # assert not item.name in globals()
    globals()[item.name] = item
"""

    def update_and_reimport_ids(self):
        if ID_VERSION_STRING != self.game_version:
            if self.verbose:
                logger.info(f"Game version is different. Updating ids")

            unit_ids = self.gather_unit_typeids()
            self.write_ids_to_file("UnitTypeId", "unit_typeid", unit_ids)
            ability_ids = self.gather_ability_ids()
            self.write_ids_to_file("AbilityId", "ability_id", ability_ids)
            upgrade_ids = self.gather_upgrades_ids()
            self.write_ids_to_file("UpgradeId", "upgrade_id", upgrade_ids)
            buff_ids = self.gather_buff_ids()
            self.write_ids_to_file("BuffId", "buff_id", buff_ids)
            effect_ids = self.gather_effect_ids()
            self.write_ids_to_file("EffectId", "effect_id", effect_ids)

            self.write_id_version_to_file()

            self.reimport_ids()
            self.update_game_data()

    def gather_unit_typeids(self):
        _ids_dict: Dict[str, int] = {}
        for unit_data in self.game_data._proto.units:
            _id: int = unit_data.unit_id
            unit_name: str = unit_data.name
            # print(unit_data)
            string = f"{unit_name}".upper().strip().replace(" ", "_")
            if not string.strip():
                continue
            if string in _ids_dict:
                if self.verbose:
                    logger.info(f"Overriding {string}-{_ids_dict[string]} with {_id}")
            _ids_dict[string] = _id
        _ids: List[Tuple[str, int]] = [(name, _id) for name, _id in _ids_dict.items()]
        _ids.sort(key=lambda k: k[1])
        return _ids

    def gather_ability_ids(self):
        # Gather data, use dict to overwrite duplicates
        _ids_dict: Dict[str, int] = {}
        for ability_data in self.game_data._proto.abilities:
            _id: int = ability_data.ability_id
            ability_link_name: str = ability_data.link_name
            ability_button_name: str = ability_data.button_name
            string = f"{ability_link_name} {ability_button_name}".upper().strip().replace(" ", "_")
            # if ability_data.remaps_to_ability_id in {3659, 3665}:
            #     print(f"Ability maps to unknown ability: {string} = {_id}")
            #     continue
            # print(ability_data)
            if not ability_data.available:
                continue
            if string[0].isnumeric():
                string = f"_{string}"
            if string in _ids_dict:
                if self.verbose:
                    logger.info(f"Ability already exists {string}-{_ids_dict[string]} with {_id}")
                c = 1
                new_string = f"{string}_{c}"
                while new_string in _ids_dict:
                    c += 1
                    new_string = f"{string}_{c}"
                _ids_dict[new_string] = _id
            else:
                _ids_dict[string] = _id

        _ids: List[Tuple[str, int]] = [(name, _id) for name, _id in _ids_dict.items()]
        _ids.sort(key=lambda k: k[1])
        return _ids

    def gather_upgrades_ids(self):
        _ids_dict: Dict[str, int] = {}
        for upgrade_data in self.game_data._proto.upgrades:
            _id: int = upgrade_data.upgrade_id
            upgrade_name: str = upgrade_data.name
            # print(upgrade_name)
            string = f"{upgrade_name}".upper().strip().replace(" ", "_")
            if not string.strip():
                continue
            if string[0].isnumeric():
                string = f"_{string}"
            if string in _ids_dict:
                if self.verbose:
                    logger.info(f"Overriding unittypeid {string}-{_ids_dict[string]} with {_id}")
            _ids_dict[string] = _id
        _ids: List[Tuple[str, int]] = [(name, _id) for name, _id in _ids_dict.items()]
        _ids.sort(key=lambda k: k[1])
        return _ids

    def gather_buff_ids(self):
        _ids_dict: Dict[str, int] = {}
        for buff_data in self.game_data._proto.buffs:
            _id: int = buff_data.buff_id
            buff_name: str = buff_data.name
            # print(buff_data)
            string = f"{buff_name}".upper().strip().replace(" ", "_")
            if not string.strip():
                continue
            if string[0].isnumeric():
                string = f"_{string}"
            if string in _ids_dict:
                if self.verbose:
                    logger.info(f"Overriding buffid {string}-{_ids_dict[string]} with {_id}")
            _ids_dict[string] = _id
        _ids: List[Tuple[str, int]] = [(name, _id) for name, _id in _ids_dict.items()]
        _ids.sort(key=lambda k: k[1])
        return _ids

    def gather_effect_ids(self):
        _ids_dict: Dict[str, int] = {}
        for effect_data in self.game_data._proto.effects:
            _id: int = effect_data.effect_id
            effect_name: str = effect_data.name
            # effect_name: str = effect_data.friendly_name
            # print(effect_data)
            string = f"{effect_name}".upper().strip().replace(" ", "_")
            if not string.strip():
                continue
            if string[0].isnumeric():
                string = f"_{string}"
            if string in _ids_dict:
                if self.verbose:
                    logger.info(f"Overriding effectid {string}-{_ids_dict[string]} with {_id}")
            _ids_dict[string] = _id
        _ids: List[Tuple[str, int]] = [(name, _id) for name, _id in _ids_dict.items()]
        _ids.sort(key=lambda k: k[1])
        return _ids

    def write_ids_to_file(self, class_name: str, ids_file_name: str, ids: List[Tuple[str, int]]):
        _ids_path = self.sc2_folder_path / "ids" / f"{ids_file_name}.py"
        # Write data to ids_file_name.py file
        with open(_ids_path, "w") as f:
            f.write(self.file_header)
            f.write(self.class_header.format(class_name))
            for name, _id in ids:
                f.write(f"    {name} = {_id}\n")
            f.write(self.file_footer.format(class_name, class_name))

    def write_id_version_to_file(self):
        _ids_path = self.sc2_folder_path / "ids" / "id_version.py"
        with open(_ids_path, "w") as f:
            f.write(f'ID_VERSION_STRING = "{self.game_version}"\n')

    def reimport_ids(self):

        # Reload the newly written "id" files
        # TODO This only re-imports modules, but if they haven't been imported, it will yield an error
        from .ids.ability_id import AbilityId

        importlib.reload(sys.modules["sc2.ids.ability_id"])
        from .ids.unit_typeid import UnitTypeId

        importlib.reload(sys.modules["sc2.ids.unit_typeid"])
        from .ids.upgrade_id import UpgradeId

        importlib.reload(sys.modules["sc2.ids.upgrade_id"])
        from .ids.effect_id import EffectId

        importlib.reload(sys.modules["sc2.ids.effect_id"])
        from .ids.buff_id import BuffId

        importlib.reload(sys.modules["sc2.ids.buff_id"])
        importlib.reload(sys.modules["sc2.ids.id_version"])
        from sc2 import constants

        importlib.reload(sys.modules["sc2.constants"])

    def update_game_data(self):
        """ Re-generate the dicts from self.game_data.
        This should be done after the ids have been reimported. """
        # ids = set(a.value for a in AbilityId if a.value != 0)
        # self.game_data.abilities = {
        #     a.ability_id: AbilityData(self.game_data, a)
        #     for a in self.game_data._proto.abilities
        #     if a.ability_id in ids
        # }
        self.game_data.abilities = {
            a.ability_id: AbilityData(self.game_data, a) for a in self.game_data._proto.abilities
        }
        self.game_data.units = {
            u.unit_id: UnitTypeData(self.game_data, u) for u in self.game_data._proto.units if u.available
        }
        self.game_data.upgrades = {u.upgrade_id: UpgradeData(self.game_data, u) for u in self.game_data._proto.upgrades}
        self.game_data.unit_types = {}
